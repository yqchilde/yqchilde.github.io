import{_ as o}from"./chunks/articleMetadata.C4FTDCLz.js";import{_ as r,B as p,a as d,u as h,E as c,e as t,H as k,ah as u,o as i,D as g,C as b}from"./chunks/framework.DYe01KkP.js";import"./chunks/theme.DYHMC7H3.js";const N=JSON.parse('{"title":"Golang的Request.Body复用","description":"在写路由中间件时有一个需求，去获取Request携带的参数然后去拦截是否合法，这时候在下游的Controller层再次去获取body竟然发现结果为空，特此记录原因和解决方案","frontmatter":{"title":"Golang的Request.Body复用","description":"在写路由中间件时有一个需求，去获取Request携带的参数然后去拦截是否合法，这时候在下游的Controller层再次去获取body竟然发现结果为空，特此记录原因和解决方案","date":"2020-12-19T13:56:15.000Z","categories":["后端"],"tags":["Golang"]},"headers":[],"relativePath":"blog/2020/golang-request-body-reuse.md","filePath":"posts/blog/2020/golang-request-body-reuse/README.md","lastUpdated":1713927161000}'),y={name:"blog/2020/golang-request-body-reuse.md"},m=t("h1",{id:"golang的request-body复用",tabindex:"-1"},[k("Golang的Request.Body复用 "),t("a",{class:"header-anchor",href:"#golang的request-body复用","aria-label":'Permalink to "Golang的Request.Body复用"'},"​")],-1),E=u(`<div class="tip custom-block"><p class="custom-block-title">背景</p><p>在写路由中间件时有一个需求，去获取Request携带的参数然后去拦截是否合法，这时候在下游的Controller层再次去获取body竟然发现结果为空，特此记录原因和解决方案</p></div><p>由于<code>http.Request.Body</code>是<code>io.ReadCloser</code>类型，所以需要带有无操作close方法的ReadCloser去复制</p><h2 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h2><div class="language-go vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设r是http.Request类型</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 我们拿到body字节流数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b, _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ioutil.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ReadAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r.Body)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用该方法继续将数据写入Body用于传递</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">r.Body </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ioutil.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NopCloser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bytes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NewBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="分析原因" tabindex="-1">分析原因 <a class="header-anchor" href="#分析原因" aria-label="Permalink to &quot;分析原因&quot;">​</a></h2><p>大多数Http框架都是这样实现的，只读一次，是因为持有的缓冲区的指针都是往前读的，如果一直持有缓冲区而不释放会出问题，可以想象一下，假如可以多次重复读，那么用户连接所产生的的内存占用的缓冲区有多大呢？什么时候释放呢？</p><p>在实际开发中，响应主体持有的资源可能会很大，所以并不会将其直接保存在内存中，只是持有数据流连接。当我们需要时，才会从服务器获取数据并返回。同时，考虑到应用重复读取数据的可能性很小，所以将其设计为<code>一次性流（one-shot）</code>,即“读取后立即关闭并释放资源”。</p>`,7);function _(s,C,f,q,B,A){const n=o,l=p("ClientOnly");return i(),d("div",null,[m,h(l,null,{default:c(()=>{var e,a;return[(((e=s.$frontmatter)==null?void 0:e.aside)??!0)&&(((a=s.$frontmatter)==null?void 0:a.showArticleMetadata)??!0)?(i(),g(n,{key:0,article:s.$frontmatter},null,8,["article"])):b("",!0)]}),_:1}),E])}const F=r(y,[["render",_]]);export{N as __pageData,F as default};
