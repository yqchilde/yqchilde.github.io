import{_ as u}from"./chunks/articleMetadata.CVLdSD8r.js";import{_ as k,m as r,a as m,u as l,B as e,e as i,x as s,aj as h,o as d,p as y,q as g}from"./chunks/framework.BKaFImy5.js";import"./chunks/theme.DGmzXqQ5.js";const v=JSON.parse('{"title":"MySQL的优化笔记","description":"整理MySQL优化相关的笔记，持续补充 🌈","frontmatter":{"title":"MySQL的优化笔记","description":"整理MySQL优化相关的笔记，持续补充 🌈","date":"2021-11-21T20:12:46.000Z","tags":["MySQL"]},"headers":[],"relativePath":"blog/2021/mysql-optimization-notes.md","filePath":"posts/blog/2021/mysql-optimization-notes/README.md","lastUpdated":1714060515000}'),b={name:"blog/2021/mysql-optimization-notes.md"},E=i("h1",{id:"mysql的优化笔记",tabindex:"-1"},[s("MySQL的优化笔记 "),i("a",{class:"header-anchor",href:"#mysql的优化笔记","aria-label":'Permalink to "MySQL的优化笔记"'},"​")],-1),q=h('<h2 id="表设计の角度" tabindex="-1">表设计の角度 <a class="header-anchor" href="#表设计の角度" aria-label="Permalink to &quot;表设计の角度&quot;">​</a></h2><h3 id="表设计原则" tabindex="-1">表设计原则 <a class="header-anchor" href="#表设计原则" aria-label="Permalink to &quot;表设计原则&quot;">​</a></h3><ol><li>一对一，通过主键关联</li><li>一对多，在多的一方设置外键</li><li>多对多，增加中间表，持有双方外键</li></ol><h3 id="使用反范式设计" tabindex="-1">使用反范式设计 <a class="header-anchor" href="#使用反范式设计" aria-label="Permalink to &quot;使用反范式设计&quot;">​</a></h3><p>严格采用一、二、三范式的设计会将系统中的表拆分的非常多，不利于查询。可以将一些冗余的字段加在必要的查询表中，从而将原本需要多表关联查询变成了单表查询，这就是反范式的目的。</p><p><strong>优缺点：</strong></p>',6),_=h(`<h3 id="设置代理主键" tabindex="-1">设置代理主键 <a class="header-anchor" href="#设置代理主键" aria-label="Permalink to &quot;设置代理主键&quot;">​</a></h3><p>什么是自然主键，什么又是代理主键？</p><ul><li>自然主键是指事物属性中的自然唯一标识，比如身份证号，学号，工号等</li><li>代理主键是指与业务无关的，无意义的数字序列值</li></ul><p>通常设计一个自增主键作为代理主键，将具体的业务逻辑ID加上索引作为自然主键，且因为代理主键使用了自增，插入时是有顺序的，对B+Tree插入影响范围较小，这样计算量也是最小的。</p><h2 id="索引优化の角度" tabindex="-1">索引优化の角度 <a class="header-anchor" href="#索引优化の角度" aria-label="Permalink to &quot;索引优化の角度&quot;">​</a></h2><h3 id="了解-索引的形式" tabindex="-1">了解 - 索引的形式 <a class="header-anchor" href="#了解-索引的形式" aria-label="Permalink to &quot;了解 - 索引的形式&quot;">​</a></h3><p>索引的存储形式是由存储引擎决定的</p><p><strong>数据表索引分类</strong></p><ul><li>从存储结构上划分： <ul><li>BTree索引（B-Tree 或 B+Tree）</li><li>Hash索引</li><li>full-index全文索引</li><li>R-Tree索引，通常用于GIS系统来表示空间数据</li></ul></li><li>从应用分层上划分： <ul><li>普通索引，普通的字段索引</li><li>唯一索引，常用于主键的索引</li><li>复合索引，用于多个条件的查询组织</li></ul></li><li>从数据的物理顺序与键值逻辑（索引）顺序关系划分： <ul><li>聚集索引，指插入顺序与索引建立顺序一致</li><li>非聚集索引</li></ul></li></ul><p>B+Tree结构</p><p><img src="https://pic.yqqy.top/blog/20211121205415.png" alt="img1" title="图1" loading="lazy"></p><p>查找8和9的路径为：</p><p><img src="https://pic.yqqy.top/blog/20211121205136.gif" alt="img2" title="图2" loading="lazy"></p><h3 id="了解-mysql常用的索引" tabindex="-1">了解 - MySQL常用的索引 <a class="header-anchor" href="#了解-mysql常用的索引" aria-label="Permalink to &quot;了解 - MySQL常用的索引&quot;">​</a></h3><ul><li>B+Tree索引 - 适合用于范围查找 <ul><li>InnoDB与MyISAM采用的是B+Tree索引</li><li>B+Tree索引采用树形链表结构建立数据“目录”</li><li>在其他字段上的索引通过和主键的索引产生关联来绑定</li></ul></li><li>Hash索引 - 适合于精确匹配 <ul><li>Hash索引基于哈希表实现</li><li>精确匹配所有列的查询才有效，不支持范围查询，模糊查询及排序</li><li>Hash索引为每条数据生成一个HashCode</li><li>Hash索引只包含哈希值和行指针</li><li>Hash取值速度非常快，但索引选择性很低时不建议使用</li><li>MySQL目前只有Memory <strong>显示</strong> 支持Hash索引</li></ul></li></ul><blockquote><p>上文说了只有在memory引擎中才会显示支持hash索引，那么在innodb中的hash索引如何创建呢？其实在Innodb中会自动帮我们创建，这里记一下他的几个特点：</p><ol><li>InnoDB存储引擎只支持显示创建BTree索引</li><li>当数据精确匹配时MySQL会自动生成HashCode，存入缓存</li></ol></blockquote><h3 id="了解-mysql中的锁" tabindex="-1">了解 - MySQL中的锁 <a class="header-anchor" href="#了解-mysql中的锁" aria-label="Permalink to &quot;了解 - MySQL中的锁&quot;">​</a></h3><table><thead><tr><th style="text-align:center;">职责分类</th><th style="text-align:center;">粒度分类</th></tr></thead><tbody><tr><td style="text-align:center;">共享锁 - 读锁</td><td style="text-align:center;">行级锁</td></tr><tr><td style="text-align:center;">独占锁（排他锁） - 写锁</td><td style="text-align:center;">表级锁</td></tr></tbody></table><ul><li>共享锁： <ul><li>这个数据可以被所有的事务连接、共享，持有该数据共享锁的所有进程都可以访问到该数据，共享锁只服务于访问，又称为读锁。</li></ul></li><li>独占锁： <ul><li>当某一个线程获得了某一条数据的访问权限时，其他所有的数据操作都将进入等待的操作，直到解锁，又称为写锁。独占锁与共享锁是互斥关系。</li></ul></li><li>行级锁： <ul><li>只对当前修改的数据进行锁定，如果不用程序访问不同数据，那彼此间是互不影响的可以并行操作的。行级锁只出现于多个程序访问同一数据时。</li></ul></li><li>表级锁： <ul><li>只要获取到表级锁，无论里面更新几条数据，该表都是锁定状态，都无法修改成功。</li><li>表级锁锁定范围比较大，行级锁锁定范围比较小，从并发性角度来说，行级锁性能比表级锁性能好；从锁自身状态管理角度来说，行级锁的开销要比表级锁大。</li></ul></li></ul><h3 id="了解-innodb引擎" tabindex="-1">了解 - InnoDB引擎 <a class="header-anchor" href="#了解-innodb引擎" aria-label="Permalink to &quot;了解 - InnoDB引擎&quot;">​</a></h3><ul><li>InnoDB支持事务</li><li>InnoDB默认使用<code>行级锁</code></li><li>InnoDB具备良好的高并发特性</li></ul><p>在InnoDB中只有利用索引的更新、删除操作，才可以使用行级锁，不能使用索引的写操作则是表级锁。 在实际开发的时候，如果遇到写操作，一定要确保<code>update/delete</code>语句的条件要能够使用索引，否则就会锁表，程序将不具备并发性。</p><h3 id="了解-什么情况下不会用到索引" tabindex="-1">了解 - 什么情况下不会用到索引 <a class="header-anchor" href="#了解-什么情况下不会用到索引" aria-label="Permalink to &quot;了解 - 什么情况下不会用到索引&quot;">​</a></h3><ul><li>索引选择性太差</li><li><code>&lt;&gt;</code>或<code>not in</code>无法使用索引</li><li><code>is null</code>会使用索引，<code>is not null</code>不会使用索引</li><li><code>where</code>子句跳过左侧索引列，直接查询右侧索引字段</li><li>对索引列进行计算或使用函数</li></ul><h3 id="优化-使用索引优化排序" tabindex="-1">优化 - 使用索引优化排序 <a class="header-anchor" href="#优化-使用索引优化排序" aria-label="Permalink to &quot;优化 - 使用索引优化排序&quot;">​</a></h3><p>当<code>order by</code>字段与索引字段顺序/排序方向相同时，索引可以优化排序速度</p><ul><li>在单字段情况下，索引支持升降序，比如：</li></ul><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># field上面有索引，where时走了索引，order by上也走了索引</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> field </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> order by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> field;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>在多字段情况下，左侧字段必须是升序，且顺序不允许打乱</li></ul><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">order by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> field必须为升序，如果用了desc，用explain分析则会是 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filesort，代表效率较差</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> field </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> order by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> field, field2;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="优化-删除冗余索引" tabindex="-1">优化 - 删除冗余索引 <a class="header-anchor" href="#优化-删除冗余索引" aria-label="Permalink to &quot;优化 - 删除冗余索引&quot;">​</a></h3><ul><li>使用<code>pt-duplicate-key-checker</code>工具，他可以帮助检测表中重复的索引或者主键，仅支持linux环境。</li><li>执行实用索引SQL语句，按照索引维度看一下磁盘I/O的处理情况</li></ul><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	object_type, object_schema, object_name, index_name,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	count_read, count_fetch, count_insert,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	count_update, count_delete</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	\`performance_schema\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.table_io_waits_summary_by_index_usage</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ORDER BY</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	sum_timer_wait </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">DESC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>count_read: 索引在计算过程中读取了多少行</li><li>count_fetch: 最终查询结果是多少行</li><li>sum_timer_wait: 利用索引查询的总时间</li><li>当后面几个查询结果全为0时，代表MySQL服务运行起来后索引没有被使用过，可以被删掉</li></ul><h3 id="优化-sql编写" tabindex="-1">优化 - SQL编写 <a class="header-anchor" href="#优化-sql编写" aria-label="Permalink to &quot;优化 - SQL编写&quot;">​</a></h3><p><strong>使用where条件</strong></p><ul><li>在精确匹配时，允许使用btree索引，比如<code>where uid = 10001</code></li><li>在范围匹配时，允许使用btree索引，比如<code>where uid &gt; 10000 and uid &lt; 10005</code></li><li>在匹配类型不一致时，比如<code>where uid = 10001</code>换成<code>where uid = &quot;10001&quot;</code>中，仍然可以使用btree索引，这是因为查询优化器会自动进行类型转换，但建议使用与定义相符的类型，减少转换操作。不过当使用<code>where uid like &quot;1000%&quot;</code>时，这时候走的就是全表扫描，查询优化器无法进行类型转换。</li></ul><hr><p><strong>使用like条件</strong></p><ul><li>在字符串字段中，btree索引允许进行“前缀查询”，比如<code>where sno like &quot;20210901000%&quot;</code>，不过查询效率与前缀有关，当选择性太低的时候，依然是全表查询</li><li>在字符串字段中，后缀查询和模糊匹配时，btree索引均不支持，比如<code>where sno like &quot;%09010001&quot;</code> 和 <code>where sno like &quot;%0901%&quot;</code></li></ul><p><strong>使用复合索引</strong></p><ul><li>复合索引查询条件必须包含左侧列</li><li>直接书写右侧列将导致数据无法查询</li><li><code>&lt;&gt;</code>与<code>not</code>会导致不使用索引</li></ul><h3 id="优化-减少表与索引碎片" tabindex="-1">优化 - 减少表与索引碎片 <a class="header-anchor" href="#优化-减少表与索引碎片" aria-label="Permalink to &quot;优化 - 减少表与索引碎片&quot;">​</a></h3><p>在数据进行频繁的增、删、改操作后，操作数据会重新组织结构。在组织过程中，可能出现一些空间的浪费以及数据组织上的不合理地方。如下两条命令就是解决该问题的：</p><ul><li><code>analyze table 表名</code>，让统计信息进行重新计算，从而让查询分析器在执行sql时基于新计算的准确的结果选择最合适的优化方案。</li><li><code>optimize table 表名</code>，对于表数据进行优化，连续的数据之间可能存在“缝隙”，在大量数据操作后，“缝隙”越来越大，此外删除的数据是被空闲下来，并不会在“表空间”这个文件中将删除数据的空间进行释放，故使用该命令重新优化表空间。<strong>执行该命令会锁表，所以一定要在维护期间，否则会造成I/O阻塞</strong></li></ul><h2 id="mysql自带の分析器" tabindex="-1">MySQL自带の分析器 <a class="header-anchor" href="#mysql自带の分析器" aria-label="Permalink to &quot;MySQL自带の分析器&quot;">​</a></h2><h3 id="开启慢sql日志分析" tabindex="-1">开启慢SQL日志分析 <a class="header-anchor" href="#开启慢sql日志分析" aria-label="Permalink to &quot;开启慢SQL日志分析&quot;">​</a></h3><ol><li>首选要开启慢SQL日志功能</li></ol><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 设置慢sql日志状态</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SET</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> GLOBAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow_query_log </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 设置慢sql执行时间阈值，单位（秒）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SET</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> GLOBAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> long_query_time </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; # 代表300毫秒</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 设置慢sql日志保存文件，路径为mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/data</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SET</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> GLOBAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> show_query_log_file </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;show-sql.log&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="利用explain执行计划" tabindex="-1">利用explain执行计划 <a class="header-anchor" href="#利用explain执行计划" aria-label="Permalink to &quot;利用explain执行计划&quot;">​</a></h3><ul><li>id：计划ID</li><li>select_type：查询类型 <ul><li>SIMPLE：简单查询，指查询不包含子查询和union</li><li>PRIMARY：复杂查询中最外侧的select</li><li>DERIVED：包含在from子句中的子查询，mysql会将结果存放在一个临时表中，也称为派生表（derived的英文含义）</li><li>SUBQUERY：子查询</li><li>UNION：连接查询</li><li>UNION RESULT：连接查询后的结果集</li></ul></li><li>table：访问的具体表名</li><li>partitions：分区表</li><li>type：表示关联类型或访问类型，即MySQL决定如何查找表中的行，执行效率排序为： <ul><li>system</li><li><strong>const</strong><ul><li>mysql能对查询的某部分进行优化并将其转化成一个常量，用于primary key 或 unique key的所有列与常数比较时，所以表最多有一个匹配行，读取一次，速度比较快</li><li><code>explain select * from (select * from film where id = 1) tmp;</code></li></ul></li><li><strong>eq_ref</strong><ul><li>primary key 或 unique key索引的所有部分被连接使用，最多只会返回一条符合条件的记录。这可能是在const之外最好的联结类型了，简单的select查询不会出现这种type</li><li><code>explain select * from film_actor left join film on film_actor.film_id = film.id</code></li></ul></li><li><strong>ref</strong><ul><li>相比eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行</li><li><code>explain select * from film where name = &quot;film1&quot;</code></li></ul></li><li>fulltext</li><li><strong>ref_or_null</strong><ul><li>类似ref，但是可以搜索值为NULL的行</li><li><code>explain select * from film where name = &quot;film1&quot; or name is null;</code></li></ul></li><li>index_merge</li><li>unique_subquery</li><li>index_subquery</li><li><strong>range</strong><ul><li>范围扫描通常出现在<code>in()</code>，<code>between</code>，<code>&gt;</code>， <code>&lt;</code>，<code>&gt;=</code>等操作中，使用一个索引来检索给定范围的行</li><li><code>explain select * from actor where id &gt; 1;</code></li></ul></li><li><strong>index</strong><ul><li>和ALL一样，不同就是mysql只需扫描索引树，这通常比ALL快一些</li><li><code>explain select count(*) from film;</code></li></ul></li><li><strong>ALL</strong><ul><li>全表扫描，意味着mysql需要从头到尾去查找所需要的行，通常这种情况下需要增加索引来优化了</li></ul></li></ul></li><li>possible_keys：显示查询可能使用哪些索引来查找</li><li>key：显示mysql实际采用哪个索引来优化对该表的访问</li><li>key_len：显示mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引的哪些列</li><li>ref：显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const、func、NULL、字段名（例：film.id）</li><li>rows：是mysql估计要读取并检测的行数，注意这个不是结果集里的行数</li><li>filtered：是一个百分比的值，代表 <code>(rows * filtered) / 100</code>，这个结果将于前表产生交互</li><li>Extra：展示的是额外信息 <ul><li>distinct: <ul><li>一旦mysql找到了与行相联合匹配的行，就不再搜索了</li><li><code>explain select distinct name from film left join film_actor on film.id = film_actor.film_id;</code></li></ul></li><li>Using index: <ul><li>又称为 <strong>索引覆盖</strong>，这发生在对表的请求列都是同一索引的部分的时候，返回的列数据只使用了索引中的信息，而没有再去访问表中的行记录，是性能高的表现</li><li><code>explain select id from film order by id;</code></li></ul></li><li>Using where: <ul><li>mysql服务器将在存储引擎检索行后再进行过滤，就是先读取整行数据，再按where条件进行检查，符合就留下，不符合就丢弃</li><li><code>explain select * from film where id &gt; 1;</code></li></ul></li><li>Using temporary: <ul><li>mysql需要创建一张临时表来处理查询，出现这种情况一般是要进行优化的，首先是想到利用索引来优化</li><li><code>explain select distinct name from actor;</code></li><li>当使用语句<code>create index idx_name on actor(name);</code>创建索引后，将会变成Using index</li></ul></li><li>Using filesort: <ul><li><ol><li>采用文件扫描对结果进行计算排序，效率很差</li></ol></li><li><code>explain select * from actor order by name;</code></li><li><ol start="2"><li>尽管在<code>name</code>上加了索引也不会使用Using index，这是因为对于排序，只有select字段与order by字段都被索引覆盖时才允许使用Using index，比如</li></ol></li><li><code>explain select name from actor order by name;</code></li><li><ol start="3"><li>再加一个字段，并且添加索引后查询，extra结果是<code>Using index; Using filesort</code></li></ol></li><li><code>explain select name, update_time from actor order by update_time, name;</code></li><li><code>create index idx_name_ut on actor(name, update_time);</code></li><li><ol start="4"><li>只有必须按照复合索引的顺序来才会使用Using index，比如</li></ol></li><li><code>explain select name, update_time from actor order by name, update_time;</code></li></ul></li></ul></li></ul><blockquote><p>id = 1 的那张表是查询的驱动表，id按照升序排列看，按顺序是依次的select，尽可能少的使用union，因为union result是使用的临时表，临时表没有索引</p></blockquote>`,52);function f(n,x,D,A,F,L){const p=u,c=r("ClientOnly"),a=r("font");return d(),m("div",null,[E,l(c,null,{default:e(()=>{var t,o;return[(((t=n.$frontmatter)==null?void 0:t.aside)??!0)&&(((o=n.$frontmatter)==null?void 0:o.showArticleMetadata)??!0)?(d(),y(p,{key:0,article:n.$frontmatter},null,8,["article"])):g("",!0)]}),_:1}),q,i("ol",null,[i("li",null,[l(a,{color:"#389e0d"},{default:e(()=>[s("单表查询易于优化，易于管理。单表的索引优化也比多个表好做，在进行排序时，多个表关联查询后order by往往是很复杂的，设计成反范式后易于简单化。")]),_:1})]),i("li",null,[l(a,{color:"#389e0d"},{default:e(()=>[s("SQL语句简单，有利于程序开发，团队协作。")]),_:1})]),i("li",null,[l(a,{color:"#f5222d"},{default:e(()=>[s("存在数据冗余，写操作时需要额外更新从表数据。")]),_:1})]),i("li",null,[l(a,{color:"#f5222d"},{default:e(()=>[s("不合理的反范式设计会让表变得臃肿不堪。")]),_:1})])]),_])}const C=k(b,[["render",f]]);export{v as __pageData,C as default};
