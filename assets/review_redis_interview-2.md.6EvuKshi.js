import{_ as d}from"./chunks/articleMetadata.CQbfghLi.js";import{_ as c,C as n,c as u,o as t,j as r,G as h,at as m,a as p,w as b,b as _,e as f}from"./chunks/framework.BQcYzY08.js";import"./chunks/theme.DGP20yfz.js";const g=JSON.parse('{"title":"Redis面试题-场景","description":"Redis面经，资源从网络收集","frontmatter":{"sort":2,"title":"Redis面试题-场景","description":"Redis面经，资源从网络收集","date":"2024-04-30T17:19:04.000Z","tags":["Redis"]},"headers":[],"relativePath":"review/redis/interview-2.md","filePath":"posts/review/redis/interview-2/README.md","lastUpdated":1715614430000}'),P={name:"review/redis/interview-2.md"};function R(a,e,k,q,S,v){const o=d,s=n("ClientOnly");return t(),u("div",null,[e[0]||(e[0]=r("h1",{id:"redis面试题-场景",tabindex:"-1"},[p("Redis面试题-场景 "),r("a",{class:"header-anchor",href:"#redis面试题-场景","aria-label":'Permalink to "Redis面试题-场景"'},"​")],-1)),h(s,null,{default:b(()=>{var i,l;return[(((i=a.$frontmatter)==null?void 0:i.aside)??!0)&&(((l=a.$frontmatter)==null?void 0:l.showArticleMetadata)??!0)?(t(),_(o,{key:0,article:a.$frontmatter},null,8,["article"])):f("",!0)]}),_:1}),e[1]||(e[1]=m('<div class="tip custom-block"><p class="custom-block-title">声明</p><p>本文中部分内容摘自网络(下方表示出处)，如有违规可联系我进行删除 🙏🏻</p><blockquote><ul><li><a href="https://github.com/chaseSpace/interview/blob/main/db_redis.md" target="_blank" rel="noreferrer">https://github.com/chaseSpace/interview/blob/main/db_redis.md</a></li></ul></blockquote></div><details class="details custom-block"><summary>目录索引</summary><nav class="table-of-contents"><ul><li><a href="#_1-缓存">1. 缓存</a></li><li><a href="#_2-延迟队列">2. 延迟队列</a><ul><li><a href="#实现方案">实现方案</a></li><li><a href="#存在问题">存在问题</a></li></ul></li><li><a href="#_3-消息队列">3. 消息队列</a><ul><li><a href="#list实现mq">List实现MQ</a></li><li><a href="#stream实现mq">Stream实现MQ</a></li><li><a href="#发布订阅实现mq">发布订阅实现MQ</a></li></ul></li></ul></nav></details><h2 id="_1-缓存" tabindex="-1">1. 缓存 <a class="header-anchor" href="#_1-缓存" aria-label="Permalink to &quot;1. 缓存&quot;">​</a></h2><p>Redis实现缓存功能的基本原理是将常用的数据存储在内存中，以加快数据访问速度，并且可以通过设置过期时间来自动淘汰过期的缓存数据。适合缓存的数据是那些更新频率较低，访问频率较高的数据，例如商品信息，用户信息等。</p><h2 id="_2-延迟队列" tabindex="-1">2. 延迟队列 <a class="header-anchor" href="#_2-延迟队列" aria-label="Permalink to &quot;2. 延迟队列&quot;">​</a></h2><p>延迟队列是一种用于处理延迟消息的队列，它的主要特点是能够在指定的时间间隔后消费消息（执行任务）。基本上类似一个任务调度服务，只是处理的对象是消息而不是任务，常见使用场景有以下几种：</p><ul><li>在购物平台下单，超时未成功付款，订单进行自动取消</li><li>打车时，规定时间内没有车主接单，订单进行自动取消</li></ul><h3 id="实现方案" tabindex="-1">实现方案 <a class="header-anchor" href="#实现方案" aria-label="Permalink to &quot;实现方案&quot;">​</a></h3><ol><li>在redis中可以使用有序集合（ZSet）来实现延迟消息队列，ZSet有一个Score属性可以用来存储延迟执行的时间。</li><li>使用<code>zadd score1 value1</code>命令就可以一直往内存中生产消息，再利用<code>zrangebyscore</code>查询复合条件的所有待处理的任务，通过循环执行队列任务即可。</li></ol><h3 id="存在问题" tabindex="-1">存在问题 <a class="header-anchor" href="#存在问题" aria-label="Permalink to &quot;存在问题&quot;">​</a></h3><ul><li>消息没有持久化，如果服务器宕机或重启，消息可能会丢失</li><li>没有ACK机制，如果消费失败，消息会丢失。有大佬实现了个支持ACK的 <a href="https://juejin.cn/post/7111939271757398023" target="_blank" rel="noreferrer">🔗 用 Redis 做一个可靠的延迟队列</a></li></ul><h2 id="_3-消息队列" tabindex="-1">3. 消息队列 <a class="header-anchor" href="#_3-消息队列" aria-label="Permalink to &quot;3. 消息队列&quot;">​</a></h2><p>常见消息队列选型Kafka、RocketMQ等服务相对Redis比较重，对于一些简单的，没有大量消息堆积的非关键业务场景可以使用Redis来实现消息队列。</p><p>Redis中可以使用List、Stream、Pub/Sub 来实现简单的消息队列</p><h3 id="list实现mq" tabindex="-1">List实现MQ <a class="header-anchor" href="#list实现mq" aria-label="Permalink to &quot;List实现MQ&quot;">​</a></h3><p>Redis队列是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。通过使用以下命令，可以实现一个简单的消息队列功能：</p><ul><li>LPUSH、RPOP 左进右出</li><li>RPUSH、LPOP 右进左出</li></ul><p>使用RPOP、LPOP命令消费数据时有个问题就是需要消费者轮询Redis，所以可以使用BRPOP、BLPOP避免这个问题。</p><h4 id="实现ack机制" tabindex="-1">实现ACK机制 <a class="header-anchor" href="#实现ack机制" aria-label="Permalink to &quot;实现ACK机制&quot;">​</a></h4><p>Redis中可以使用双队列来实现ACK机制，步骤如下：</p><ul><li>准备两个队列，其中存储数据的队列为<code>queue1</code>，另一个队列名为<code>queue1_bak</code></li><li>消费者使用<code>RPOPLPUSH</code><a href="https://www.modb.pro/db/13773" target="_blank" rel="noreferrer"> ① </a>或<code>BRPOPLPUSH</code>命令消费数据（数据在弹出的同时将备份到另一个 bak 队列）</li><li>消费者消费数据成功后，使用<code>LREM</code>命令消费 bak 队列的数据</li><li>启用定时任务，使用<code>LRANGE</code>命令读取队列数据，解析每条数据（需要包含产生时间戳），将超市消息（认为消费失败）重新入队<code>queue1</code><ul><li>超时定义：因为使用redis的队列场景一般不存在大量消息堆积，所以可以简单定一个时间</li><li>因为这里的超时定义不严谨，所以建议消息中包含唯一ID实现幂等消费，否则可能会重新消费</li></ul></li></ul><h3 id="stream实现mq" tabindex="-1">Stream实现MQ <a class="header-anchor" href="#stream实现mq" aria-label="Permalink to &quot;Stream实现MQ&quot;">​</a></h3><p>Stream是Redis5.0引入的一种专门为消息队列设计的数据结构，Stream是一个包含0个或者多个元素的有序队列，这些元素根据ID的大小进行有序排列，它实现了大部分消息队列的功能：</p><ul><li>消息ID序列化生成</li><li>消息遍历</li><li>消息的阻塞和非阻塞读</li><li>Consumer Groups(消费组) <ul><li>消费组的目的是通过多个消费者同时消费一个队列，实现负载均衡和容错</li><li>通过<code>XGROUP</code> / <code>XREADGROUP</code> / <code>XACK</code>实现消费组功能</li></ul></li><li>ACK确认机制</li><li>支持多播</li><li>提供了很多消息队列操作命令</li><li>提供了消息持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失</li></ul><p><strong>参考</strong></p><ul><li><a href="https://www.cnblogs.com/uniqueDong/p/15959687.html" target="_blank" rel="noreferrer">别再用 Redis List 实现消息队列了，Stream 专为队列而生</a></li></ul><h3 id="发布订阅实现mq" tabindex="-1">发布订阅实现MQ <a class="header-anchor" href="#发布订阅实现mq" aria-label="Permalink to &quot;发布订阅实现MQ&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>严格来说，“发布订阅”只是一个广播机制，而不是真正的消息队列，因为不支持消息累积，从而无法实现MQ必备的异步通信功能。</p></div><p>Redis通过<code>PUBLISH</code>、<code>SUBSCRIBE</code> 等命令实现了订阅与发布模式，这个功能提供两种信息机制，分别是<code>订阅 / 发布</code>到频道和<code>订阅 / 发布</code> 到模式（一个类似正则表达式的key）</p><p><code>订阅 / 发布</code>模式包含两种角色，分别是发布者和订阅者，订阅者可以订阅一个或多个<code>channel</code>，而发布者可以向指定的<code>channel</code>发送消息，所有订阅此频道的订阅者都会收到此消息</p><p><strong>缺点</strong><br> 由于Redis不会存储消息，所以只有在线的订阅者可以实时接收消息，并且没有ACK机制，离线订阅者会永远丢失消息</p>',31))])}const M=c(P,[["render",R]]);export{g as __pageData,M as default};
